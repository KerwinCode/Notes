# C++ 内存布局

本文将以 **Linux x86_64** 系统为例，总结 C++ 程序内存布局。

## 图示 (以 Linux x86_64 为例)

```text
/------------------\  <-- 0xFFFFFFFFFFFFFFFF (高地址)
|                  |
|      内核空间     |
|   (Kernel Space)   |  用户代码不可访问
|                  |
\------------------/  <-- 0xFFFF800000000000
|       ...        |      (内核空间与用户空间之间有巨大的“空洞”)
|       ...        |
/------------------\
|       栈区       |  <-- 命令行参数、环境变量
|      (Stack)     |
|                  |
|  <-- 向下增长  ↓   |  <-- (栈顶指针 %rsp) 局部变量、函数参数...
|                  |
\------------------/  <-- (地址随机化)
|                  |
|     内存映射区    |  <-- (地址随机化)
| (Memory Mapping) |  共享库(.so), mmap映射文件
|                  |
/------------------\
|                  |
|   ↑  向上增长 -->  |  <-- (brk指针) 动态分配的内存
|       堆区       |
|      (Heap)      |
\------------------/  <-- (地址随机化)
/------------------\
|      BSS 段      |  未初始化/初始化为0的全局/静态变量
\------------------/
/------------------\
|     数据段       |  已初始化的全局/静态变量
|   (.data)        |
\------------------/
/------------------\
|   只读数据段     |  字符串常量, const常量
|   (.rodata)      |
\------------------/
/------------------\
|      代码段      |  程序的可执行指令
|   (.text)        |
\------------------/  <-- 0x0000000000400000 (通常的起始地址, 受ASLR影响)
                         (低地址)
```

## 说明

这张图展示了在一个64位Linux操作系统上，一个C++程序运行时的虚拟内存空间布局。虚拟内存使得每个进程都认为自己独占了整个内存空间。这个空间从低地址到高地址可以分为以下几个主要部分：

### 1.  **代码段 (.text)**

* **位置**：用户空间的最低地址部分。在64位系统下，启用ASLR（地址空间布局随机化）后，其基地址也会有一定程度的随机化，但通常会从一个较低的地址开始，比如 `0x400000` 附近。
* **内容**：存放程序编译后的二进制机器指令。CPU就是从这里读取并执行指令的。
* **特点**：
    * **只读 (Read-Only)**：防止程序在运行时意外地修改了自己的指令，保证程序的稳定性。
    * **可共享 (Shareable)**：如果系统中有多个该程序的实例在运行，它们可以共享同一份物理内存中的代码段，节约内存资源。

### 2.  **只读数据段 (.rodata)**

* **位置**：紧跟在代码段之后。
* **内容**：存放不会在程序运行期间被修改的数据，主要是：
    * **字符串字面量**：例如 `const char* s = "hello world";` 中的 `"hello world"`。
    * **const修饰的全局变量**：例如 `const int PI = 3.14;`。
* **特点**：**只读**。任何试图修改这部分内存的操作都会导致段错误 (Segmentation Fault)。

### 3.  **数据段 (.data)**

* **位置**：位于.rodata段之上。
* **内容**：存放程序中**已显式初始化**的全局变量和静态变量（包括静态局部变量和静态全局变量）。
    * `int global_var = 10;` // 全局变量
    * `static int static_var = 20;` // 静态全局变量
* **特点**：**可读可写 (Read-Write)**。这部分数据的大小在编译时就已经确定，并且其内容直接从可执行文件中加载。

### 4.  **BSS段 (.bss - Block Started by Symbol)**

* **位置**：紧跟在数据段之后。
* **内容**：存放**未初始化**或**初始化为0**的全局变量和静态变量。
    * `int global_uninit;`
    * `static int static_zero = 0;`
* **特点**：
    * **可读可写**。
    * 在可执行文件中不占用空间，只是记录了需要多少内存。当程序加载时，由操作系统内核将这块内存区域**全部清零**。这是为了节省可执行文件的体积。

### 5.  **堆区 (Heap)**

* **位置**：位于BSS段之上。
* **内容**：用于**动态内存分配**。当程序调用 `new` (C++) 或 `malloc` (C) 时，申请的内存就来自堆区。
* **特点**：
    * **向上增长**：堆的分配是从低地址向高地址进行的。通过移动一个叫做`brk`的指针来扩展堆的大小。
    * **手动管理**：程序员需要手动通过 `delete` 或 `free` 来释放不再使用的内存。忘记释放会导致**内存泄漏**；释放后继续使用会导致**悬挂指针**问题。
    * **不连续**：频繁的分配和释放容易产生内存碎片。

### 6.  **内存映射区 (Memory Mapping Segment)**

* **位置**：位于堆和栈之间的广阔区域。
* **内容**：这是一个非常灵活的区域，用于：
    * **加载共享库**：程序依赖的动态链接库（.so文件）会被映射到这里。
    * **文件映射**：通过 `mmap()` 系统调用，可以将一个文件直接映射到内存中，像操作内存一样读写文件，提高I/O效率。
    * **匿名映射**：也可以创建不与任何文件关联的内存区域。
* **特点**：地址通常是随机化的，可以动态地映射和解除映射。

### 7.  **栈区 (Stack)**

* **位置**：位于用户空间的高地址部分。
* **内容**：存放与函数调用相关的一切信息。每当一个函数被调用，就会在栈顶创建一个“栈帧”（Stack Frame），包含：
    * **函数参数**。
    * **函数内部的局部变量**（非`static`修饰）。
    * **函数调用的返回地址**（即函数执行完毕后应该回到哪里继续执行）。
* **特点**：
    * **向下增长**：栈是从高地址向低地址扩展的。栈顶指针（在x86-64中是 `%rsp` 寄存器）会随着数据的压栈（push）而减小。
    * **自动管理**：由编译器自动分配和释放。函数调用时创建栈帧，函数返回时销毁栈帧，无需程序员干预。
    * **大小有限**：栈的大小通常是固定的（如8MB）。无限递归或定义过大的局部数组会导致**栈溢出 (Stack Overflow)**。
    * 在栈的最高处，通常还存放着**命令行参数** (`argc`, `argv`) 和**环境变量**。

### 8.  **内核空间 (Kernel Space)**

* **位置**：位于整个虚拟地址空间的最高部分（从`0xFFFF800000000000`到`0xFFFFFFFFFFFFFFFF`）。
* **内容**：存放操作系统的核心代码和数据。
* **特点**：
    * **受保护**：为了保护操作系统的稳定和安全，用户模式下的程序**不能直接访问**内核空间的内存。
    * **共享**：所有进程共享同一个内核空间。
    * **特权访问**：当程序需要执行特权操作（如文件I/O、网络通信）时，必须通过**系统调用**陷入内核模式，由内核代为执行，然后将结果返回给用户程序。
